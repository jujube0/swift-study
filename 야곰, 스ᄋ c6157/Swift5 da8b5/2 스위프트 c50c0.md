# 2. 스위프트 시작하기

Created: February 1, 2022 5:25 PM

# 기본 명명 규칙

- 함수, 메서드, 인스턴스의 이름은 lower-camel-case를 사용한다
- 클래스, 구조체, 익스텐션, 프로토콜, 열거형 이름은 타입의 이름이기 때문에 첫 글자를 대문자로 사용하는 upper-camel-case를 사용

# 콘솔 로그

## print()

```swift
public func print(items: Any..., 
	seperator: String = default, 
	terminator: String = default)
```

- 자동으로 줄바꿈 문자를 마지막에 삽입해준다.

## dump()

- print보다 자세한 내용을 출력해준다.
- 인스턴스 내부의 콘텐츠까지 함께 출력한다.

## 문자열 보간법String interpolation

```swift
"My Name Is \(var or let)"
```

- 기본적으로 인스턴스의 description 프로퍼티를 사용하여 문자열로 치환한다.
- CustomStringConvertible 플고토콜을 준수할 때 구현하면 된다.

## 변수와 상수

- 변수: var
    - 생성 후 값을 변경할 수 있다
- 상수: let
    - 생성 후 값을 변경 불가하다.

# 데이터 타입 기본

## Int와 UInt

- Int는 +, - 부호를 포함한 정수
- UInt는 양을 포함한 양의 정수 only
- 비트에 따라 Int8, Int16..Int64, UInt8, UInt16...UInt64
- 플랫폼이 64비트 환경이면 Int64가 Int 타입이 된다.
- 같은 정수라 해도 Int, UInt가 전혀 다른 타입으로 인식하기 때문에 두 타입간 교환에서 자원이 소모된다.
- → 통일하는 것이 좋다.

### 진수

- 2진수: 접두어 `0b`
- 8진수: 접두어 `0o`
- 16진수: 접두어 `0x`

```swift
var binaryInteger: Int = 0b11100
print(binaryInteger) // 28
```

## Bool

## Float과 Double

- 64비트 Double, 32비트 Float
- 64비트 환경에서 Double은 최소 15자리의 십진수를 표현 가능, Float은 6자리만 가능
- 헷갈리면 Double

## Character

## String

- character의 나열

```swift
let greeting = """
안녕하세요!
잘하고 싶어요 스위프트
"""
```

- 큰따옴표 세개를 사용해서 여러 줄의 문자열을 표현할 수 있다. 이 경우 큰 따옴표를 쓰고 한 줄을 내려쓰고, 마지막 줄에도 한 줄 내려서 큰 따옴표를 써줘야한다.

## 특수문자

- `\n` 줄바꿈
- `\\` 문자열 내에서 백슬래시
- `\"`
- `\t` 탭 문자
- `\0` 문자열이 끝났음을 알리는 null 문자

## Any, AnyObject와 nil

- Any
    - 모든 데이터 타입이 가능하다.
- AnyObject
    - Any보다는 조금 한정된 의미
    - 클래스의 인스턴스만 할당 가능하다.

# 데이터 타입 고급

## typealias

```swift
typealias MyInt = Int
typealias YourInt = Int
```

- 모든 데이터 타입에 임의로 다른 이름을 부여할 수 있다.

## tuple

- 지정된 데이터의 묶음
- 파이썬의 튜플과 유사하다

```swift
var person: (String, Int, Double) = ("yagom", 100, 182.5)

print(person.0)

person.1 = 99
```

- 인덱스를 통해 값을 할당할 수도 있고
- 값을 가져올 수도 있다.
- 각 요소에 이름을 지어줄 수도 있다.
    
    ```swift
    var person: (name: String, age: Int, height: Double) = ("yagom", 100, 182.5)
    
    print(person.name)
    
    print(person.0)
    person.2 = 178.1
    ```
    
    - 이 경우 인덱스와 요소 이름을 통해 각 요소에 접근하고, 값을 할당할 수 있다.
- typealias와 함께 이용하면 좋다.

## collections

- array, dictionary, set
- array
    - `let` 을 사용하면 immutable, `var` 을 사용하면 mutable
    - `Array<Type>` 또는 `[Type]` 으로 선언 가능하다.
    
    ```swift
    var emptyArray: [Any] = [Any]()
    var emptyArray: [Any] = Array<Any>()
    var emptyArray: [Any] = []
    ```
    
    - 잘못된 인덱스에 접근하면 exception error가 발생한다.
- dictionary
    - 순서 없는 key-value 쌍
    - `let` 사용하면 immutable, `var` 사용하면 mutable
    - typealias 사용하면 좋다.
    
    ```swift
    var numberForName: Dictionary<String, Int> = Dictionary<String, Int>()
    var numberForName: [String: Int] = [String: Int]()
    
    typealias StringDictionary = [String: Int]
    var numberForName: StringDictionary = StringDictionary()
    
    var numberForName: [String: Int] = [:]
    ```
    
    - 키는 유일해야 하고, 값은 상관 없다.
    - 내부에 없는 키로 접근하면 nil을 반환한다. *에러가 생기지 않는다.
- set
    - 같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장
    - 세트 요소로는 Hashable 프로토콜을 따르는 값들만 가능하다. 기본 데이터타입은 모두 Hashable이다.
    
    ```swift
    var names: Set<String> = Set<String>()
    var names: Set<String> = []
    
    var names: Set<String> = ["yagom", "chulsoo", "yagom"]
    print(names.count) // 2
    ```
    
- enums
    - 연관된 항목들을 묶어서 표현
    
    ```swift
    enum School {
    	case primary, elementary,
    	case middle
    }
    ```
    
    - 한 줄에 나열할 수도 있고, 여러줄에 하나씩 나열할 수도 있다.
    - 각 항목 자체로도 하나의 값이지만, 각 항목에 대응되는 raw value를 가질 수도 있다.
    - `rawValue` 프로퍼티를 통해 접근하자
        
        ```swift
        enum School: String {
        	case primary = "유치원"
        	case elementary = "초등학교"
        }
        
        let highestEducationLevel: School = .primary
        print(highestEducationLevel.rawValue)
        ```
        
    - 일부 항목만 원시 값을 줄 수도 있다.
        - 나머지는 문자열 형식의 원시값을 지정해줬다면 각 항목 이름을 그대로 원시 값으로 갖게되고
        - 정수타입이라면 첫 항목을 기준으로 0부터 1씩 늘어난 값을 갖게된다.
    - 원시값을 통해 enum 변수/상수를 생성해줄 수도 있다. 올바르지 않은 원시값을 이용하면 nil을 반환한다.
        
        ```swift
        let primary = School(rawValue: "유치원") //primary
        let graduate = School(rawValue: "석박사") // nil
        ```
        
    - associated values
        - 열거 형 내의 항목(case)이 자신과 연관된 값을 가질 수 있다.
        - 일부만 연관값을 가져도 된다.
        
        ```swift
        enum MainDish {
        	case pasta(taste: String)
        	case pizza(dough: String, topping: String)
        	case rice
        }
        
        var dinner: MainDish = .pasta(tase: "크림)
        dinner = .rice
        ```
        
    - `CaseInterable` 프로토콜을 채택할 경우 `allCases` 라는 타입 프로퍼티를 통해 모든 케이스의 컬렉션을 생성해준다.
        - 플랫폼에 따라 케이스가 달라지거나 associated value를 갖는 경우에는 `allCases` 프로퍼티를 직접 구현해준다.
    - 열거형 항목의 연관 값으로 self(enum)을 사용하고 싶을 때에는 `indirect` 키워드를 사용한다.
        - 특정 항목에만 사용하고 싶은 경우에는 case 키워드 앞에
        - 전체에 적용하고 싶으면 enum 키워드 앞에

# 연산자

## 사용자 정의 연산자

```swift
prefix operator ** // **를 전위 연산자로 정의

prefix func ** (value: Int) -> Int {
	return value * value
}

print(**(-5)) // 25
```

# 흐름 제어

## switch

- `fallthrough` 바로 다음 case 문을 실행한다.

### tuple

- wildcard `_`
    
    ```swift
    typealias NameAge = (name: String, age: Int)
    
    let tupleValue: NameAge = ("yagom", 99)
    
    switch tupleValue {
    case ("yagom", _):
        print("이름만 맞았습니다")
    default:
        print("누굴 찾나요?")
    }
    ```
    
- 값 바인딩
    
    ```swift
    typealias NameAge = (name: String, age: Int)
    
    let tupleValue: NameAge = ("yagom", 99)
    
    switch tupleValue {
    case (let name, 99):
        print("나이만 맞았습니다. 이름은 \(name)입니다")
    default:
        print("누굴 찾나요?")
    }
    ```
    
- where을 통한 확장
    
    ```swift
    let 직급: String = "사원"
    let 연차: Int = 1
    let 인턴인가: Bool = false
    
    switch 직급 {
    case "사원" where 인턴인가 == true:
        print("인턴입니다")
    default:
        print("누구십니까?)
    }
    ```
    
- 열거형처럼 한정된 범위의 값을 입력 값으로 받는 경우에는 default를 구현하지 않아도 된다.
- 차후에 열거형의 추가된 case를 해결해주는 것을 원한다면 `unknown` 속성을 사용할 수 있다.
- `@unknown case _` 를 이용하면, 남은 case를 대비해주면서 이에 대한 경고를 띄워준다.

## 반복문

- do-while 문은 repeat-while 문을 이용해야한다.
    
    ```swift
    var i = 3
    repeat {
    	print("bye)
    	i--
    } while i > 0
    ```
    
    - repeat 블록 코드를 1회 실행한 후 블록 내부 코드를 반복 실행한다.

## 구문 이름표

- 반복문 앞에 이름과 함께 colon을 붙여 구문의 이름을 지정
- 제어 키워드와 구문 이름을 이용하여 지정된 구문을 제어한다.
    
    ```swift
    var numbers: [Int] = [3, 2342, 6, 3252]
    
    numbersLoop: for num in numbers {
    if num > 5 || num < 1 {
        continue numbersLoop
    }
    var count = 0
    
    printLoop: while true {
        print(num)
        count += 1
    
        if count == num {
            break printLoop
        }
    }
    
    removeLoop: while true {
        if numbers.first != num {
            break numbersLoop
        }
        numbers.removeFirst()
    }
    }
    ```
    

# 함수

- 구조체, 클래스, 열거형 등 **특정 타입에 연관되어 사용하는 함수를 메서드**
- **모듈 전체에서 전역적으로 사용할 수 있는 함수를 그냥 함수**라고 부른다.

## 매개변수

- 가변 매개변수
    - 매개변수로 몇 개의 값이 들어올지 모를 때
    - 0개 이상의 값을 받아올 수 있으며
    - 인자 값은 배열처럼 사용할 수 있다.
    - 함수마다 가변 매개변수는 항상 하나만 가질 수 있다.
    
    ```swift
    func sayHelloToFriends(me: String, friends names: String...) {
        for friend in names {
            print("Hello \(friend)")
        }
        print("I'm \(me)")
    }
    
    sayHelloToFriends(me: "lauren", friends: "nylah", "terry", "river")
    ```
    
- 입출력 매개변수
    - 값이 아닌 참조를 전달할 때
    - `inout` 매개변수로 전달될 변수 또는 상수 앞에 `&` 를 붙여서 표현한다.
    
    ```swift
    var numbers: [Int] = [1,2,3]
    
    func referenceParameter(_ arr: inout [Int]) {
        arr[1] = 1
    }
    
    referenceParameter(&numbers)
    print(numbers[1])
    ```
    
    - default 값을 가질 수 없고, 가변 매개변수로도 사용될 수 없다.
    - memory safety 를 위협할 수 있다.
- 데이터 타입으로서의 함수
    - 전달인자 label은 함수 타입의 구성 요소가 아니므로 함수 타입을 작성할 때에는 이용할 수 없다.
    - `let someFunction: (lhs: Int, rhs: Int) -> Int` // 오류
    - `let someFunction: (_ lhs: Int, _ rhs: Int) -> Int` // OK
    - `let someFunction: (Int, Int) -> Int` // OK

## 중첩함수

- 특별한 위치에 들어가지 않은 함수는 모두 전역함수이다.
- 함수 내에 함수를 선언함으로써 사용 범위를 한정할 수도 있다.
- 중첩 함수를 반환하게 하여 함수 외부에서 이를 이용하게 할 수도 있다.

## 종료(return)되지 않는 함수

- nonreturning function(or method)
- `Never` 타입을 리턴하는 함수.
- 오류를 던지거나, 중대한 시스템 오류를 보고하는 등의 일을 한 후 프로세스를 종료한다.
- 이 함수를 실행하면 프로세스의 동작은 멈추게 된다.

## 반환 값을 무시할 수 있는 함수

- 반환값을 사용하지 않았다는 경고를 없애는 것
- `@discardableResult` 키워드를 함수 선언 시 사용한다.

# 옵셔널

: 값이 있을 수도, 없을 수(nil)도 있음

- 데이터 타입 뒤에 물음표를 붙여 표현해준다.

```swift
var myName: String? = "yagom"
```

## 옵셔널 enum의 정의

```swift
public enum Optional<Wrapped> : ExpressibleByNilLiteral {
		case none
		case some(Wrapped)
		public init(_ some: Wrapped)
		// 중략
}
```

→ enum이기 때문에 switch를 통해 값의 유무를 판단 가능하다.

```swift
switch optionalValue {
	case .none:
		//
	case .some(let value):
		//
}
```

## 옵셔널 언래핑

1. 강제추출

느낌표를 붙여주면 된다. 간단하지만 위험

1. 옵셔널 바인딩

if 또는 while 문과 결합하여 사용한다.

```swift
var myName: String? = "yagom"

if let name = myName {
	print("not optional)
}
```

1. 암시적 추출 옵셔널implicit unwrapped optional

nil을 할당 가능하지만, 이용할 때는 옵셔널이 아닌 것처럼 이용한다.

타입 뒤에 느낌표를 붙여주면 되고,

로직상 nil 때문에 런타임 오류가 일어나지 않을 것이 확실할 때만 이용해야 한다.

옵셔널이기 때문에 옵셔널 바인딩을 사용할 수는 있다.

```swift
var myName: String! = "yagom"
print(myName)
myName = nil

if let name = myName {
	print("not nil")
} 
// not nil
myName.isEmpty // error
```